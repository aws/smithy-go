//go:build ignore
// +build ignore

package main

import (
	"log"
	"os"
	"strings"
	"text/template"
)

var tmpl = template.Must(template.New("generate").
	Funcs(map[string]any{
		"privateSymbol": func(v string) string {
			return strings.TrimSpace(strings.ToLower(v[0:1]) + v[1:])
		},
		"publicSymbol": func(v string) string {
			return strings.TrimSpace(strings.ToUpper(v[0:1]) + v[1:])
		},
		"join": func(v ...string) string {
			return strings.Join(v, "")
		},
	}).
	Parse(`
{{- block "root" $ -}}
// Code generated by transport/internal/fieldset. DO NOT EDIT.

package transport

// FieldSet is a collection of fields grouped by their usage.
type FieldSet struct {
{{- range $name, $_ := $.Locations -}}
	{{ (privateSymbol $name) }} *fields
{{ end -}}
}

// NewFieldSet returns an initalized FieldSet.
func NewFieldSet() *FieldSet {
	return &FieldSet{
	{{- range $name, $_ := $.Locations }}
		{{ (privateSymbol $name) }}: newFields(),
	{{ end -}}
	}
}

{{ range $name, $_ := $.Locations -}}
{{ $privateName := (privateSymbol $name) -}}
{{ $publicName := (publicSymbol $name) -}}
{{ $get := (join "Get" $publicName) -}}
// {{ $get }} retrieves the {{ $name }} Field by name, by performing a
// case-insensitive lookup.
func (fs *FieldSet) {{ $get }}(name string) Field {
	return fs.{{ $privateName }}.Get(name)
}

{{ $has := (join "Has" $publicName) -}}
// {{ $has }} returns whether a matching {{ $name }} Field exists for the given
// name using case-insensitive lookup.
func (fs *FieldSet) {{ $has }}(name string) bool {
	return fs.{{ $privateName }}.Has(name)
}

{{ $set := (join "Set" $publicName) -}}
// {{ $set }} adds field to set of {{ $name }} Fields. If a {{ $name }} field
// with the same name exists (case-insensitive matching), that field's is
// replaced with the values from the provided field, with the casing of the
// name remaining the same. If the field doesn't exist, then it will be added.
// Returns the old field and true if the field already existed, otherwise
// returns false.
func (fs *FieldSet) {{ $set }}(field Field) (old Field, ok bool) {
	return fs.{{ $privateName }}.Set(field)
}

{{ $remove := (join "Remove" $publicName) -}}
// {{ $remove }} searches the {{ $name }} Fields for a Field matching the
// provided name (case-insensitive), and removes the field if found. Returns
// the old field and true if the field was removed, otherwise returns false.
func (fs *FieldSet) {{ $remove }}(name string) (old Field, ok bool) {
	return fs.{{ $privateName }}.Remove(name)
}

{{ $getFields := (join "Get" $publicName "Fields") -}}
// {{ $getFields }} returns a copy of the {{ $publicName }} fields. Any
// modifications to the returned slice of Fields will not be reflected upstream
// in the FieldSet.
func (fs *FieldSet) {{ $getFields }}() []Field {
	return fs.{{ $privateName }}.GetFields()
}
{{- end -}}
{{- end }}
`))

func main() {
	file, err := os.Create("fieldset.go")
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Fatal(err)
		}
	}()

	err = tmpl.Execute(file, struct {
		Locations map[string]struct{}
	}{
		Locations: map[string]struct{}{
			"header": {},
		},
	})
	if err != nil {
		log.Fatal(err)
	}
}
